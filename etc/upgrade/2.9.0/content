my @OUR_QUEUES = ('Incidents', 'Incident Reports', 'Investigations', 'Blocks');

@Initial = (
    sub {
        return 1 if grep $_ eq 'RT::IR', RT->Config->Get('Plugins');

        die "Please enable RT::IR plugin in the config file.\n";
    },
);

sub remove_scrip_action {
    my $module = shift;

    my $actions = RT::ScripActions->new( $RT::SystemUser );
    $actions->Limit( FIELD => 'ExecModule', VALUE => $module );
    while ( my $action = $actions->Next ) {
        my $scrips = RT::Scrips->new( $RT::SystemUser );
        $scrips->Limit( FIELD => 'ScripAction', VALUE => $action->id );
        while ( my $scrip = $scrips->Next ) {
            $scrip->Delete;
        }
        $action->DBIx::SearchBuilder::Record::Delete();
    }
}

sub remove_scrip_condition {
    my $module = shift;

    my $conditions = RT::ScripConditions->new( $RT::SystemUser );
    $conditions->Limit( FIELD => 'ExecModule', VALUE => $module );
    while ( my $condition = $conditions->Next ) {
        my $scrips = RT::Scrips->new( $RT::SystemUser );
        $scrips->Limit( FIELD => 'ScripCondition', VALUE => $condition->id );
        while ( my $scrip = $scrips->Next ) {
            $scrip->Delete;
        }
        $condition->DBIx::SearchBuilder::Record::Delete();
    }
}

sub get_queue {
    my $qname = shift;

    my $queue = RT::Queue->new( $RT::SystemUser );
    $queue->Load( $qname );
    unless ( $queue->id ) {
        $RT::Logger->error("Couldn't load queue '$qname'");
        return;
    }
    return $queue;
}

sub get_queue_and_state_cf {
    my $queue = get_queue( @_ );
    return unless $queue;

    my $cf = RT::CustomField->new( $RT::SystemUser );
    $cf->LoadByName( Name => 'State', Queue => $queue->id );
    unless ( $cf->id ) {
        $RT::Logger->error("Couldn't load State custom field applied to queue '$qname'");
        return;
    }
    return ($queue, $cf);
}

sub custom_field_real_values {
    my $cf = shift;
    my %args = @_;
    my $values = RT::ObjectCustomFieldValues->new( $RT::SystemUser );
    $values->Limit( FIELD => 'CustomField', VALUE => $cf->id );
    $values->Limit( FIELD => 'Disabled', VALUE => 0 )
        unless $args{'Inactive'};
    return grep defined && length,
        $values->DistinctFieldValues('Content');
}

@Final = (

    # IP type change
    sub {
        my $ip_cf = RT::CustomField->new($RT::SystemUser);
        $ip_cf->Load('IP');
        if ( $ip_cf->id ) {
            $ip_cf->SetType('IPAddressRange');
            $ip_cf->SetMaxValue(0);
            $ip_cf->SetPattern('');
        }
    },

    # set lifecycles on queues
    sub {
        for my $name ( @OUR_QUEUES ) {
            my $queue = RT::Queue->new($RT::SystemUser);
            $queue->Load( $name );
            unless ( $queue->id ) {
                $RT::Logger->error("Couldn't load queue '$name'");
                next;
            }

            my $new_cycle = lc $name;
            $new_cycle =~ s/ /_/;

            if ( $queue->Lifecycle->Name eq $new_cycle ) {
                $RT::Logger->debug("Queue $name already uses '$new_cycle' lifecycle");
                next;
            }

            my ($status, $msg) = $queue->SetLifecycle( $new_cycle );
            unless ( $status ) {
                $RT::Logger->error("Couldn't change lifecycle: $msg");
                next;
            }

            $RT::Logger->debug("Changed lifecycle of queue '$name' to '$new_lifecycle'");
        }
    },

    # in RTIR queues for variouse reasons we kept Status and State in
    # sync with each other and were hiding these txns in the UI. Now
    # we delete old status changes
    # and convert State changes into Status changes

    # update tickets' Status column from ObjectCustomFieldValues table
    sub {
        for my $qname ( @OUR_QUEUES ) {
            my ($queue, $cf) = get_queue_and_state_cf( $qname );
            next unless $queue && $cf;

            my @states = custom_field_real_values( $cf );

            foreach my $state ( @states ) {
                my $values = RT::ObjectCustomFieldValues->new( $RT::SystemUser );
                $values->Limit( FIELD => 'CustomField', VALUE => $cf->id );
                $values->Limit( FIELD => 'Disabled', VALUE => 0 );
                $values->Limit( FIELD => 'Content', VALUE => $state );
                $values->Columns('ObjectId');

                my $res = $RT::Handle->SimpleUpdateFromSelect(
                    'Tickets', { Status => $state }, $values->BuildSelectQuery
                );
                $RT::Logger->error("Couldn't update tickets: $res")
                    unless $res;
            }
        }
    }

    # delete tickets' Status changes (txns) in RTIR queues,
    sub {
        for my $qname ( @OUR_QUEUES ) {
            my $queue = RT::Queue->new( $RT::SystemUser );
            $queue->Load( $qname );
            unless ( $queue->id ) {
                $RT::Logger->error("Couldn't load queue '$qname'");
                next;
            }

            my $query = "SELECT txn.id FROM Transactions txn JOIN Tickets t"
                ." WHERE txn.ObjectType = 'RT::Ticket' AND txn.ObjectId = t.id"
                ." AND t.Type = 'ticket' AND t.Queue = ?"
                ." AND ((txn.Type = 'Set' AND txn.Field = 'Status') OR txn.Type = 'Status')"
            ;
            my $res = $RT::Handle->DeleteFromSelect( 'Transactions', $query, $queue->id );
            $RT::Logger->error("Couldn't delete transactions: $res")
                unless $res;
        }
    },

    # CF.State => Status
    sub {
        my %state;
        for my $queue ( @OUR_QUEUES ) {
            my $state = RT::CustomField->new($RT::SystemUser);
            $state->LoadByName( Name => 'State', Queue => $queue );
            $state{$queue} = $state if $state->id;
        }

        my $Tickets = RT::Tickets->new($RT::SystemUser);
        $Tickets->UnLimit;
        while ( my $ticket = $Tickets->Next ) {
            my $qname = $ticket->QueueObj->Name;
            next unless grep lc $qname eq lc $_, @OUR_QUEUES;

            my $txns = $ticket->Transactions;
            my %done; # in case redo search bite
            while ( my $txn = $txns->Next ) {
                next if $done{$txn->id}++;
                if ($txn->Type eq 'CustomField'
                    && $txn->Field == $state{ $ticket->QueueObj->Name }->id )
                {
                    $txn->__Set( Field => 'Type', Value => 'Set' );
                    $txn->__Set( Field => 'Field', Value => 'Status' );
                    $txn->__Set( Field => 'ReferenceType', Value => '' );

                    if ( $txn->OldReference ) {
                        $ocfv =
                          RT::ObjectCustomFieldValue->new($RT::SystemUser);
                        $ocfv->Load( $txn->OldReference );
                        $txn->__Set(
                            Field => 'OldValue',
                            Value => $ocfv->Content
                        );
                        $txn->__Set( Field => 'OldReference', Value => '' );
                        $ocfv->Delete;
                    }

                    if ( $txn->NewReference ) {
                        $ocfv =
                          RT::ObjectCustomFieldValue->new($RT::SystemUser);
                        $ocfv->Load( $txn->NewReference );
                        $txn->__Set(
                            Field => 'NewValue',
                            Value => $ocfv->Content
                        );
                        $txn->__Set( Field => 'NewReference', Value => '' );
                        $ocfv->Delete;
                    }
                }
            }
        }
    },


    # un-apply and disable State custom fields
    sub {
        for my $qname ( @OUR_QUEUES ) {
            my ($queue, $cf) = get_queue_and_state_cf( $qname );
            next unless $queue && $cf;

            {
                my ($status, $msg) = $cf->RemoveFromObject( $queue );
                $RT::Logger->error("Couldn't unapply custom field #". $cf->id .": $msg")
                    unless $status;
            }

            unless ( $cf->Disabled ) {
                my ($status, $msg) = $cf->SetDisabled(1);
                $RT::Logger->error("Couldn't disable custom field #". $cf->id .": $msg")
                    unless $status;
            }
        }
    },


    # remove no longer needed scrip actions and scrips based on them
    sub {
        # started date is handled by lifecycles now
        remove_scrip_action('RTIR_SetStartedToNow');
        # IRs and Blocks has some special status treatment, but
        # it is handled by other scrips
        remove_scrip_action('RTIR_SetIncidentReportState');
        remove_scrip_action('RTIR_SetBlockState');
        # Investigations and Incidents don't need special status
        # treatment, it was only sync with State CF
        remove_scrip_action('RTIR_SetInvestigationState');
        remove_scrip_action('RTIR_SetIncidentState');
    },

    # remove no longer needed scrip conditions and scrips based on them
    sub {
        # started date is handled by lifecycles now
        remove_scrip_condition('RTIR_RequireStateChange');
    },
);
