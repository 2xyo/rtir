<%args>
$url_params => undef
$content => undef
$ticket => undef
</%args>
<%once>
use Regexp::Common qw(URI net);
use URI::URL;

my $web_path = RT->Config->Get('WebPath');
my $url_params_once;
my $incident;
my $left = '\b';
my $right = '\b';
#my $left = qr[[\w\b\.\,<(\[]];
#my $right = qr[[\w\b\.\,>)\]]];

my %cb = (
   default => sub {
     my ($type,$value) = @_;
     return qq{<a href="$web_path/RTIR/Tools/Lookup.html?${url_params_once}q=${value}">$value</a>};
   },
   ip => 
   sub {
     my ($type,$value) = @_;
     my $result = qq[<a href="$web_path/RTIR/Tools/Lookup.html?@{[$url_params_once]}type=ip&q=${value}">$value</a>];
     if ($incident) {
       $result .= qq[ [<a href="$web_path/RTIR/Create.html?Incident=$incident&Queue=Blocks&IP-Value=$value">Block</a>] ];
     }
     return $result;
   },
   ipdecimal =>
   sub {
     my ($type,$value) = @_;
     my $i = unpack "L",$value;
     return $value unless $value > 33554432;
     my $host = do {
       my $hostnum = sprintf "%lx", $i;
       my $a = hex( substr( $hostnum, 0, 2 ) );
       my $b = hex( substr( $hostnum, 2, 2 ) );
       my $c = hex( substr( $hostnum, 4, 2 ) );
       my $d = hex( substr( $hostnum, 6, 2 ) );
       "$a.$b.$c.$d";
     };
   my $result;
   $result = qq[$value <a href="$web_path/RTIR/Tools/Lookup.html?@{[$url_params_once]}type=ip&q=$host">($host)</a>];
   if ($incident) {
      $result .= qq[[<a href="$web_path/RTIR/Create.html?Incident=$incident&Queue=Blocks&IP-Value=$host">Block</a>] ];
   }
   return $result;
   },
   email =>
   sub {
     my ($type,$value) = @_;
     my ($pre,$post) = split /@/,$value,2;
     my $result = qq[<a href="$web_path/RTIR/Tools/Lookup.html?@{[$url_params_once]}type=email&q=$value">$value</a> ];
if ($incident) {
    if ($r->uri =~ /Lookup.html$/) {
	$result .= qq[<input type="checkbox" name="Requestorbox-$value" unchecked />];
    }
    $result .= qq[[<a href="$web_path/RTIR/Create.html?Incident=$incident&Queue=Investigations&Requestors=$value">Investigate to</a>] ];
}
     $result .= qq[<a href="$web_path/RTIR/Tools/Lookup.html?@{[$url_params_once]}type=host&q=$post">($post)</a>];
 },
   url =>
   sub {
     my ($type,$value) = @_;
     my $uri  = URI::URL->new($value);
     my $host = $uri->host;
     return qq[<a target="new" href="$value">$value</a> ].
       qq[<a href="$web_path/RTIR/Tools/Lookup.html?@{[$url_params_once]}type=host&q=$host">($host)</a>];
   },
   noc =>
   sub {
     my ($type,$value) = @_;
     return qq[<a href="$web_path/RTIR/Tools/Lookup.html?@{[$url_params_once]}type=handle&q=$value">$value</a>];
   },
   host =>
   sub {
     my ($type,$value) = @_;
     my $result =  qq[<a href="$web_path/RTIR/Tools/Lookup.html?@{[$url_params_once]}type=host&q=$value">$value</a>];
     return $result;
   },
  );

# key -> [ regexp, callback, _recache ]
my %types =
  (
   Ahttpurl	=> [ $RE{URI}{HTTP}{-keep}{-scheme => 'https?'}, $cb{url}],
   Bip		=> [ q[\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}], $cb{ip} ],
   Cipdecimal	=> [ q[\d{8,13}(?!=)], $cb{ipdecimal} ],
   Demail	=> [ q[(?:mailto:)?[\w\.\+-]+\@[\w\.-]+\.\w{2,3}], $cb{email}],
   Fdomain	=> [ q[(?:[\w-]+\.)+[A-Za-z]{2,3}], $cb{host} ],
   GRIPE	=> [ q[(?-i:[A-Z][A-Z0-9-]+)], $cb{noc} ],
  );
my @types = sort keys %types;

for my $type (@types) {
  my $d = $types{$type};
  $d->[2]  = '^' . $d->[0] . '$';
}

my $regexp =
  join "|",
  map $left.$_.$right,
  map $_->[0],
  map $types{$_},
  @types;

sub handle {
  my $what = $1;
  for my $type (@types) {
    my $d = $types{$type};
    if ($what =~ $d->[2]) {
      my $sub = $d->[1] || $cb{default};
      return $sub->($type,$what);
    }
  }
}

</%once>
<%init>
$url_params_once=$ARGS{url_params};

$incident = undef;
if ($ticket && $ticket->QueueObj->Name eq 'Incidents') {
  $incident = $ticket->Id;
}

if ($url_params_once && $url_params_once !~ /&$/) {
        $url_params_once .= "&";
}
for ( $$content =~ s/($regexp)/&handle($1||"")/gsieo ) {1}
return();
</%init>
<%doc>
# Thoughts:

# 1. Regexp::Common doesn't seem to deal with URL's with user:pass in
# them very well.  Someone send Abigail up a patch.  (Note, we're now
# doing the HTTP thing first.)

# 2. We're doing a big substitution on the whole content, and then
# re-matching each little piece.  Does it make sense to make 5 passes
# over the big text

# 4. Callbacks are cool


</%doc>

