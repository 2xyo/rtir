%# BEGIN LICENSE BLOCK
%# 
%# Copyright (c) 1996-2003 Jesse Vincent <jesse@bestpractical.com>
%# 
%# (Except where explictly superceded by other copyright notices)
%# 
%# This work is made available to you under the terms of Version 2 of
%# the GNU General Public License. A copy of that license should have
%# been provided with this software, but in any event can be snarfed
%# from www.gnu.org
%# 
%# This work is distributed in the hope that it will be useful, but
%# WITHOUT ANY WARRANTY; without even the implied warranty of
%# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
%# General Public License for more details.
%# 
%# 
%# Unless otherwise specified, all modifications, corrections or
%# extensions to this work which alter its source code become the
%# property of Best Practical Solutions, LLC when submitted for
%# inclusion in the work.
%# 
%# 
%# END LICENSE BLOCK
<h1>RTIR Periodic Report</h1>

<table>
  <tr>
    <td>Start date:</td>
    <td> <%$rtstart->AsString%></td>
  </tr>
  <tr>
    <td>End date:</td>
    <td><%$rtend->AsString%></td>
  </tr>
</table>

<table>
<th align=left colspan=2>Incident Report Summary</th>
<tr>
  <td>Outstanding reports at the beginning of this period</td>
  <td class=value> <%$outstanding->Count%></td>
</tr>
<tr>
  <td>Total new reports for this period</td>
  <td><% $tix_created->Count%></td>
</tr>
<tr>
  <td>Incident Reports resolved during this period</td>
  <td><% $tix_resolved->Count%></td>
</tr>
<tr>
  <td>Reports unresolved at the end of the period</td>
  <td><% $tix_unresolved->Count%></td>
</tr>
</table>

<table>
<th align=left colspan=2>Incident reports received</th>

<%perl>

foreach my $key (sort keys %$classifications) {
    my $class = $classifications->{$key};
    my $class_count = 0;
    while ( my $t = $tix_created->Next) {
	my $value = get_incident_field( $t, '_RTIR_Classification');
	next if ($class ne 'Unclassified' && $value ne $class);
	next if ($class eq 'Unclassified' && $value ne "");
	$class_count++;
    }

</%perl>

<tr>
  <td><%$class%></td>
  <td class=value><%$class_count%></td>
</tr>

<%perl>
}
</%perl>

</table>

<%perl>
foreach my $incident_type (keys %$types) {
</%perl>

<h2><%$incident_type%></h2>

<%perl>
# of new reports created during the month broken down by classification
$Queue->Load('Incident Reports');
$CustomFields = $Queue->CustomFields();
$CustomFields->{'find_disabled_rows'} = 1;
while (my $CustomField = $CustomFields->Next()) {
  if ($CustomField->Name eq '_RTIR_SLA') {
    $fid = $CustomField->Id;
    my $values = $CustomField->Values;
    while (my $value = $values->Next) {
      $windows->{$value->Name} = $value->Description;
    }
  }
}

foreach my $service_level (keys %$windows) {
    my $class_tix = RT::Tickets->new( $session{'CurrentUser'} );
    $class_tix->LimitQueue(VALUE => 'Incident Reports');
    $class_tix->LimitCreated(VALUE => $start, OPERATOR => ">");
    $class_tix->LimitCreated(VALUE => $end, OPERATOR => "<");
    $class_tix->LimitCustomField(CUSTOMFIELD => $fid, VALUE => $service_level);

    my $class_sla_tix = RT::Tickets->new( $session{'CurrentUser'} );
    $class_sla_tix->DEBUG(1);
    $class_sla_tix->Limit( QUOTEVALUE => 1, ENTRYAGGREGATOR => 'AND', FIELD => 'Started', OPERATOR => '<', VALUE => '(Created + 7200)' );

    my ($tix_count, $sla_count, $resolved_count, $unresolved_count);
    $tix_count = 0;
    $sla_count = 0;
    $resolved_count = 0;
    $unresolved_count = 0;

    # get the number of seconds for the service level
    my $sla = $RT::SLA->{$service_level} * 60;

    while ( my $t = $class_tix->Next) {
      # find the parent incident
      my $incidents = $t->MemberOf;
      my $parent;
      while (my $link = $incidents->Next) {
        my $incident = $link->TargetObj;
        if ($incident->QueueObj->Name eq 'Incidents') {
          $parent = $incident;
	  last;
        }
      }
      if ( $parent &&
	   $parent->FirstCustomFieldValue('_RTIR_Function') eq $incident_type) {
        if ( $t->ResolvedObj->Unix <= 0 ||
             $t->ResolvedObj->Unix > $monthend->Unix) {
          $tix_count++;
        }
        if ( $t->StartedObj->Unix > 0 &&
             $t->StartedObj->Unix < ($t->CreatedObj->Unix + $sla)) {
          $sla_count++;
        }
        if ( $t->ResolvedObj->Unix >= $monthstart->Unix &&
             $t->ResolvedObj->Unix <= $monthend->Unix) {
          $resolved_count++;
        }
        if ( $t->ResolvedObj->Unix <= 0 ||
             $t->ResolvedObj->Unix > $monthend->Unix) {
          $unresolved_count++;
        }
      }
    }

</%perl>

<h3><%$service_level%></h3>

<table width=100%>
<tr>
  <td valign=top width=50%>
    <table>
      <th colspan=2>At the start of the time period:</th>
      <tr>
        <td class=label>Outstanding Incident Reports:</td>
        <td class=value> <%$outstanding->Count%></td>
      </tr>
    </table>
  </td>
  <td valign=top width=50%>
    <table>
      <th colspan=2>During the time period:</th>
      <tr>
       <td>Total <%$service_level%> Incident Reports created:</td>
	<td><% $tix_count %></td>
      </tr>
      <tr>
        <td>
          Incident Reports for which response time was met:
        </td>
	<td><% $sla_count %></td>
      </tr>
      <tr>
        <td>Resolved Incident Reports:</td>
	<td><% $resolved_count%></td>
      </tr>
      <tr>
        <td>Unresolved Incident Reports: </td>
	<td><% $unresolved_count%></td>
      </tr>
    </table>
  </td>
</tr>
</table>
% }
% }
<%perl>

#                  All tickets created in queue IncidentReport created after
#                  monthstart and before monthend where
#                  there was outbound correspondence within $windows{$Classification};
#
# No need to break down incident type against response time.
# classification (eg response time) needs to be calculated somehow, and to
# take account of nwh. (eg the clock stops tickets at 1800 and starts
# again at 0800 and reports received at 8am on a Saturday are not measured
# until 0800 Monday ownwards...etc)
#
# eg
#  All tickets created in queue IncidentReport created after monthstart and
#  before monthend where there was outbound correspondence within
#  $windows{$Classification};
#
my $sla_check = RT::Tickets->new( $session{'CurrentUser'} );

#$sla_check->FromSQL( "Created >= $monthstart AND Created <= $monthend AND Queue='Incident Reports'");

# Get a Business::Hours object for the period in question
use Business::Hours;

my $business_hours = Business::Hours->new();
#$business_hours->set_business_hours(%working_hours);
#$business_hours->for_timespan( Start => $monthstart->AsString, End => $monthend->AsString );
my %created;

while ( my $t = $sla_check->Next) {

    my $sla = $t->FirstCustomFieldValue('SLA');

    #my $time_on_clock = $business_hours->between( $t->CreatedObj->Unix, $t->ResolvedObj->Unix );

    # of email messages created by CERT staff, broken down by Queue (incident, incident report, investigation)
    # of email messages received by CERT, broken down by Queue (incident, incident report, investigation)
    my $txns = RT::Transactions->new( $session{'CurrentUser'} );
    $txns->Limit( FIELD => 'Created', OPERATOR => '>=', VALUE => $monthstart );
    $txns->Limit( FIELD => 'Created', OPERATOR => '<=', VALUE => $monthstart );
    while ( my $txn = $txns->Next ) {
        my $q = $txn->TicketObj->QueueObj->Name;
        my $inbound = ( $txn->IsInbound || 0 );
        $created{$q}{$inbound}++;
    }

    #         Average time from creation to close for incidents for all incidents
    #         closed within this time period
    # 	This doesn't currently take into account "business hours"

    my $avgtime = RT::Tickets->new( $session{'CurrentUser'} );
#    $avgtime->FromSQL( "Queue = 'Incident Reports' AND Resolved >= '$monthstart' AND Resolved <= '$monthend'");

    my $i;
    my $total_diff;
    while ( my $t = $avgtime->Next ) {
        $i++;
        my $ctime = $t->CreatedObj->Unix;
        my $rtime = $t->ResolvedObj->Unix;

        my $diff = $rtime - $ctime;
        $total_diff += $diff;

    }

    my $average_secs;
    if ($i) {
     $average_secs = $total_diff / $i;
    }
}
</%perl>

<%init>
my $now = new RT::Date($RT::SystemUser);
$now->SetToNow();

my $monthstart = new RT::Date($RT::SystemUser);
$monthstart->Set(Format => 'ISO', Value => ParseDateToISO($mystart));

my $monthend = new RT::Date($RT::SystemUser);
$monthend->Set(Format => 'ISO', Value => ParseDateToISO($myend));

my $start = $monthstart->ISO;
my $end = $monthend->ISO;

</%init>

<%args>
$mystart => undef
$myend => undef
</%args>
